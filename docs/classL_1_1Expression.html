<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>L-Solver: L::Expression Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="design.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">L-Solver
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Generic implementation of standard decomposition algorithms for MILP and MINLP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceL.html">L</a></li><li class="navelem"><a class="el" href="classL_1_1Expression.html">Expression</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classL_1_1Expression-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">L::Expression Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a mathematical expression as an expression tree.  
 <a href="classL_1_1Expression.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Expression_8h_source.html">Expression.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for L::Expression:</div>
<div class="dyncontent">
<div class="center"><img src="classL_1_1Expression__coll__graph.png" border="0" usemap="#L_1_1Expression_coll__map" alt="Collaboration graph"/></div>
<map name="L_1_1Expression_coll__map" id="L_1_1Expression_coll__map">
<area shape="rect" id="node2" href="classL_1_1CoreVariable.html" title="Implements a variable. " alt="" coords="16,81,128,108"/>
<area shape="rect" id="node3" href="classL_1_1AbstractVariable.html" title="Implements the interface for variables. " alt="" coords="5,5,139,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad571b6d602257ff0af3b50f97eaa2a02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#ad571b6d602257ff0af3b50f97eaa2a02">Expression</a> ()=default</td></tr>
<tr class="memdesc:ad571b6d602257ff0af3b50f97eaa2a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ad571b6d602257ff0af3b50f97eaa2a02">More...</a><br /></td></tr>
<tr class="separator:ad571b6d602257ff0af3b50f97eaa2a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ee72782c47a4b5a1d8614600f38cb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a96ee72782c47a4b5a1d8614600f38cb8">Expression</a> (<a class="el" href="namespaceL.html#a30852e05bf02e4de3ad59078615f7b75">ExpressionType</a> <a class="el" href="classL_1_1Expression.html#a581b6516fa543f9d01f19c45e273282e">type</a>)</td></tr>
<tr class="memdesc:a96ee72782c47a4b5a1d8614600f38cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new expression whose root node is of the given type.  <a href="#a96ee72782c47a4b5a1d8614600f38cb8">More...</a><br /></td></tr>
<tr class="separator:a96ee72782c47a4b5a1d8614600f38cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cfac300978eeb619bf99c7ad50dad7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a67cfac300978eeb619bf99c7ad50dad7">Expression</a> (const <a class="el" href="classL_1_1Variable.html">Variable</a> &amp;variable)</td></tr>
<tr class="memdesc:a67cfac300978eeb619bf99c7ad50dad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new expression whose root is of type Var and is associated to the given variable.  <a href="#a67cfac300978eeb619bf99c7ad50dad7">More...</a><br /></td></tr>
<tr class="separator:a67cfac300978eeb619bf99c7ad50dad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cf2c3800815337e91f49bafcb79674"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a12cf2c3800815337e91f49bafcb79674">Expression</a> (float coef)</td></tr>
<tr class="memdesc:a12cf2c3800815337e91f49bafcb79674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new expression whose root is of type Num and has value 'coef'.  <a href="#a12cf2c3800815337e91f49bafcb79674">More...</a><br /></td></tr>
<tr class="separator:a12cf2c3800815337e91f49bafcb79674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e9e1a9637b14ffd7c14b620405883f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a11e9e1a9637b14ffd7c14b620405883f">Expression</a> (const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memdesc:a11e9e1a9637b14ffd7c14b620405883f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. The whole expression tree is copied.  <a href="#a11e9e1a9637b14ffd7c14b620405883f">More...</a><br /></td></tr>
<tr class="separator:a11e9e1a9637b14ffd7c14b620405883f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519ba150940dedfa5dd54e90ce472f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a519ba150940dedfa5dd54e90ce472f39">operator=</a> (const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memdesc:a519ba150940dedfa5dd54e90ce472f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign constructor. The whole expression is copied.  <a href="#a519ba150940dedfa5dd54e90ce472f39">More...</a><br /></td></tr>
<tr class="separator:a519ba150940dedfa5dd54e90ce472f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100166b8c53e7bf1e6aa67f37ccf6274"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a100166b8c53e7bf1e6aa67f37ccf6274">~Expression</a> ()</td></tr>
<tr class="memdesc:a100166b8c53e7bf1e6aa67f37ccf6274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Frees left and right children.  <a href="#a100166b8c53e7bf1e6aa67f37ccf6274">More...</a><br /></td></tr>
<tr class="separator:a100166b8c53e7bf1e6aa67f37ccf6274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2ee1e7c303fd02663f6c0d0193332e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1Variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a4a2ee1e7c303fd02663f6c0d0193332e">as_variable</a> ()</td></tr>
<tr class="memdesc:a4a2ee1e7c303fd02663f6c0d0193332e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable associated to the expression if the expression is of type Var (otherwise, throws an exception)  <a href="#a4a2ee1e7c303fd02663f6c0d0193332e">More...</a><br /></td></tr>
<tr class="separator:a4a2ee1e7c303fd02663f6c0d0193332e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb3585f71cde564157bf83501efdf9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1ConstVariable.html">ConstVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#aecb3585f71cde564157bf83501efdf9b">as_variable</a> () const</td></tr>
<tr class="memdesc:aecb3585f71cde564157bf83501efdf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable associated to the expression if the expression is of type Var (otherwise, throws an exception)  <a href="#aecb3585f71cde564157bf83501efdf9b">More...</a><br /></td></tr>
<tr class="separator:aecb3585f71cde564157bf83501efdf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfbdbec325596ac33e93d10a26d2e3c"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a0cfbdbec325596ac33e93d10a26d2e3c">as_numerical</a> ()</td></tr>
<tr class="memdesc:a0cfbdbec325596ac33e93d10a26d2e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numerical constant associated to the expression if the expression if of type Num (otherwise, throws an exception)  <a href="#a0cfbdbec325596ac33e93d10a26d2e3c">More...</a><br /></td></tr>
<tr class="separator:a0cfbdbec325596ac33e93d10a26d2e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e35984f46ddc7528981da4a73ec148"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#ac4e35984f46ddc7528981da4a73ec148">as_numerical</a> () const</td></tr>
<tr class="memdesc:ac4e35984f46ddc7528981da4a73ec148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numerical constant associated to the expression if the expression if of type Num (otherwise, throws an exception)  <a href="#ac4e35984f46ddc7528981da4a73ec148">More...</a><br /></td></tr>
<tr class="separator:ac4e35984f46ddc7528981da4a73ec148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96e86a455a561989b129c397dcff02b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#af96e86a455a561989b129c397dcff02b">has_child</a> (<a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> side) const</td></tr>
<tr class="memdesc:af96e86a455a561989b129c397dcff02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the expression has a child on its 'side', false otherwise.  <a href="#af96e86a455a561989b129c397dcff02b">More...</a><br /></td></tr>
<tr class="separator:af96e86a455a561989b129c397dcff02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc55fb8bdbbe2024130809f542182286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#afc55fb8bdbbe2024130809f542182286">child</a> (<a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> side)</td></tr>
<tr class="memdesc:afc55fb8bdbbe2024130809f542182286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the child node located on the expression's 'side' (Left/Right) if any, throws an exception otherwise.  <a href="#afc55fb8bdbbe2024130809f542182286">More...</a><br /></td></tr>
<tr class="separator:afc55fb8bdbbe2024130809f542182286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d02c47d04b26ff8f1bbcb914cfa08e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a60d02c47d04b26ff8f1bbcb914cfa08e">child</a> (<a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> side) const</td></tr>
<tr class="memdesc:a60d02c47d04b26ff8f1bbcb914cfa08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the child node located on the expression's 'side' (Left/Right) if any, throws an exception otherwise.  <a href="#a60d02c47d04b26ff8f1bbcb914cfa08e">More...</a><br /></td></tr>
<tr class="separator:a60d02c47d04b26ff8f1bbcb914cfa08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9196bd881e791dccd790893fa7648c0"><td class="memItemLeft" align="right" valign="top">unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#ab9196bd881e791dccd790893fa7648c0">id</a> () const</td></tr>
<tr class="memdesc:ab9196bd881e791dccd790893fa7648c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns expression's id.  <a href="#ab9196bd881e791dccd790893fa7648c0">More...</a><br /></td></tr>
<tr class="separator:ab9196bd881e791dccd790893fa7648c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581b6516fa543f9d01f19c45e273282e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceL.html#a30852e05bf02e4de3ad59078615f7b75">ExpressionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a581b6516fa543f9d01f19c45e273282e">type</a> () const</td></tr>
<tr class="memdesc:a581b6516fa543f9d01f19c45e273282e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns expression's type.  <a href="#a581b6516fa543f9d01f19c45e273282e">More...</a><br /></td></tr>
<tr class="separator:a581b6516fa543f9d01f19c45e273282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a0bd394ee1290f2b91cfcac60cc944"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#ad2a0bd394ee1290f2b91cfcac60cc944">attach</a> (<a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> side, <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;expr)</td></tr>
<tr class="memdesc:ad2a0bd394ee1290f2b91cfcac60cc944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the expression's 'side' child to be 'expr'. No copy is performed. Thus, '&amp;expr' will be destroyed by the expression's constructor.  <a href="#ad2a0bd394ee1290f2b91cfcac60cc944">More...</a><br /></td></tr>
<tr class="separator:ad2a0bd394ee1290f2b91cfcac60cc944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a615a5aea5ad9827f6f68063dd4f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a5a9a615a5aea5ad9827f6f68063dd4f1">attach_copy</a> (<a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> side, const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;expr)</td></tr>
<tr class="memdesc:a5a9a615a5aea5ad9827f6f68063dd4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the expression's 'side' child to be 'expr'. The given expression is copied.  <a href="#a5a9a615a5aea5ad9827f6f68063dd4f1">More...</a><br /></td></tr>
<tr class="separator:a5a9a615a5aea5ad9827f6f68063dd4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cf5ee5682c0c0f2c2b0b3c055c6045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#af2cf5ee5682c0c0f2c2b0b3c055c6045">insert</a> (<a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> side, <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;expr)</td></tr>
<tr class="memdesc:af2cf5ee5682c0c0f2c2b0b3c055c6045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the expression's 'side' child to be 'expr'. If the expression already has a 'side' child, it will be moved to 'expr''s side.  <a href="#af2cf5ee5682c0c0f2c2b0b3c055c6045">More...</a><br /></td></tr>
<tr class="separator:af2cf5ee5682c0c0f2c2b0b3c055c6045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8fb4f5a0efea1cb21f6bfac962d4ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a9a8fb4f5a0efea1cb21f6bfac962d4ac">shift</a> (<a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> side)</td></tr>
<tr class="memdesc:a9a8fb4f5a0efea1cb21f6bfac962d4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the root node to the 'side'. The expression therefore ends with a child which is the previous root.  <a href="#a9a8fb4f5a0efea1cb21f6bfac962d4ac">More...</a><br /></td></tr>
<tr class="separator:a9a8fb4f5a0efea1cb21f6bfac962d4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064f326a3b41c6462454489a77f4b25f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a064f326a3b41c6462454489a77f4b25f">detach_delete</a> (<a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> side)</td></tr>
<tr class="memdesc:a064f326a3b41c6462454489a77f4b25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and deletes (frees memory) a child. For memory safety reasons, no "detach" without delete (memory free) has been implemented. See transfer/swap for alternatives.  <a href="#a064f326a3b41c6462454489a77f4b25f">More...</a><br /></td></tr>
<tr class="separator:a064f326a3b41c6462454489a77f4b25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b7b1109603397df3d0cb1b440bfaeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a59b7b1109603397df3d0cb1b440bfaeb">operator+=</a> (const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memdesc:a59b7b1109603397df3d0cb1b440bfaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition overload. See <a class="el" href="classL_1_1Expression.html#a6a0f0ca9ac1d72a75d61e4a2d64c8764" title="Applies an operator (&#39;*&#39; or &#39;+&#39;) on &#39;this&#39; with rhs as right term. ">apply_operator()</a>.  <a href="#a59b7b1109603397df3d0cb1b440bfaeb">More...</a><br /></td></tr>
<tr class="separator:a59b7b1109603397df3d0cb1b440bfaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26c7d426f321c2ecc03b7462d7e0cf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#ac26c7d426f321c2ecc03b7462d7e0cf4">operator*=</a> (const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac26c7d426f321c2ecc03b7462d7e0cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product overload. See <a class="el" href="classL_1_1Expression.html#a6a0f0ca9ac1d72a75d61e4a2d64c8764" title="Applies an operator (&#39;*&#39; or &#39;+&#39;) on &#39;this&#39; with rhs as right term. ">apply_operator()</a>.  <a href="#ac26c7d426f321c2ecc03b7462d7e0cf4">More...</a><br /></td></tr>
<tr class="separator:ac26c7d426f321c2ecc03b7462d7e0cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7c56ec0c7611529025ac685363158b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a1d7c56ec0c7611529025ac685363158b">operator-=</a> (const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memdesc:a1d7c56ec0c7611529025ac685363158b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction overload.  <a href="#a1d7c56ec0c7611529025ac685363158b">More...</a><br /></td></tr>
<tr class="separator:a1d7c56ec0c7611529025ac685363158b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b6afa689d58f2916c6ea5458fb49ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a28b6afa689d58f2916c6ea5458fb49ed">operator/=</a> (const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memdesc:a28b6afa689d58f2916c6ea5458fb49ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division overload.  <a href="#a28b6afa689d58f2916c6ea5458fb49ed">More...</a><br /></td></tr>
<tr class="separator:a28b6afa689d58f2916c6ea5458fb49ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5f871de69faea528cec83250cdcb5a"><td class="memTemplParams" colspan="2">template&lt;ExpressionTraversalOrder order&gt; </td></tr>
<tr class="memitem:abd5f871de69faea528cec83250cdcb5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#abd5f871de69faea528cec83250cdcb5a">depth_first_traversal</a> (const std::function&lt; void(<a class="el" href="classL_1_1Expression.html">Expression</a> &amp;expr)&gt; &amp;f)</td></tr>
<tr class="memdesc:abd5f871de69faea528cec83250cdcb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic implementation of the Depth first traversal on the expression tree. Early stop of the traversal can be performed by throwing a <a class="el" href="classL_1_1StopIteration.html">StopIteration</a> exception.  <a href="#abd5f871de69faea528cec83250cdcb5a">More...</a><br /></td></tr>
<tr class="separator:abd5f871de69faea528cec83250cdcb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601268b35451070221a668c0404464d9"><td class="memTemplParams" colspan="2">template&lt;ExpressionTraversalOrder order&gt; </td></tr>
<tr class="memitem:a601268b35451070221a668c0404464d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a601268b35451070221a668c0404464d9">depth_first_traversal</a> (const std::function&lt; void(const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;expr)&gt; &amp;f) const</td></tr>
<tr class="memdesc:a601268b35451070221a668c0404464d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic implementation of the Depth first traversal on the expression tree. Early stop of the traversal can be performed by throwing a <a class="el" href="classL_1_1StopIteration.html">StopIteration</a> exception.  <a href="#a601268b35451070221a668c0404464d9">More...</a><br /></td></tr>
<tr class="separator:a601268b35451070221a668c0404464d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccd934cf538ce1e31cf099b3ebbb130"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a3ccd934cf538ce1e31cf099b3ebbb130">feval</a> (bool cast_variables=true)</td></tr>
<tr class="memdesc:a3ccd934cf538ce1e31cf099b3ebbb130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the numerical value of an expression.  <a href="#a3ccd934cf538ce1e31cf099b3ebbb130">More...</a><br /></td></tr>
<tr class="separator:a3ccd934cf538ce1e31cf099b3ebbb130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7640c4e69d9982c46387ecc8650216d9"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classL_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a7640c4e69d9982c46387ecc8650216d9">split_by_variable</a> (const std::map&lt; std::string, std::function&lt; bool(const <a class="el" href="classL_1_1Variable.html">Variable</a> &amp;)&gt;&gt; &amp;indicators)</td></tr>
<tr class="memdesc:a7640c4e69d9982c46387ecc8650216d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of variable indicators, i.e., a set of lambda function which respond true for some variables and false for others, returns a set of subexpressions composed only of those variables for which the associated indicator returns true for all of its variables. Note that the given indicators MUST define a separable expression in those variables. For instance, "x * y" cannot be separated by the two following indicators: <code>c++ [](const <a class="el" href="classL_1_1Variable.html" title="Indirection to a core variable. ">Variable</a>&amp; var){ return var.user_defined_name() == "x"; } and [](const <a class="el" href="classL_1_1Variable.html" title="Indirection to a core variable. ">Variable</a>&amp; var){ return var.user_defined_name() == "y"; }</code>.  <a href="#a7640c4e69d9982c46387ecc8650216d9">More...</a><br /></td></tr>
<tr class="separator:a7640c4e69d9982c46387ecc8650216d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c88ee27d7574232d07c441c823410f5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a2c88ee27d7574232d07c441c823410f5">to_elementary_string</a> () const</td></tr>
<tr class="memdesc:a2c88ee27d7574232d07c441c823410f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string expression representing the expression's root node.  <a href="#a2c88ee27d7574232d07c441c823410f5">More...</a><br /></td></tr>
<tr class="separator:a2c88ee27d7574232d07c441c823410f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd9b53defd859a111733f0d180a32b7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a7cd9b53defd859a111733f0d180a32b7">to_string</a> () const</td></tr>
<tr class="memdesc:a7cd9b53defd859a111733f0d180a32b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression as a string.  <a href="#a7cd9b53defd859a111733f0d180a32b7">More...</a><br /></td></tr>
<tr class="separator:a7cd9b53defd859a111733f0d180a32b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5c6d5640489c62efcba84dbceca4c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a6b5c6d5640489c62efcba84dbceca4c4">export_to_dot</a> (const std::string &amp;filename, bool with_system_command=true) const</td></tr>
<tr class="memdesc:a6b5c6d5640489c62efcba84dbceca4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the expression tree in a .dot file to be used with graphviz. If 'with_system_command' is set to true, the linux command 'dot -Tpng' is executed.  <a href="#a6b5c6d5640489c62efcba84dbceca4c4">More...</a><br /></td></tr>
<tr class="separator:a6b5c6d5640489c62efcba84dbceca4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a6a0f0ca9ac1d72a75d61e4a2d64c8764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a6a0f0ca9ac1d72a75d61e4a2d64c8764">apply_operator</a> (<a class="el" href="namespaceL.html#a30852e05bf02e4de3ad59078615f7b75">ExpressionType</a> <a class="el" href="classL_1_1Expression.html#a581b6516fa543f9d01f19c45e273282e">type</a>, const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memdesc:a6a0f0ca9ac1d72a75d61e4a2d64c8764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an operator ('*' or '+') on 'this' with rhs as right term.  <a href="#a6a0f0ca9ac1d72a75d61e4a2d64c8764">More...</a><br /></td></tr>
<tr class="separator:a6a0f0ca9ac1d72a75d61e4a2d64c8764"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afb26b29e8d5d8fcc05a2418e3163c816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceL.html#a30852e05bf02e4de3ad59078615f7b75">ExpressionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#afb26b29e8d5d8fcc05a2418e3163c816">_type</a> = <a class="el" href="namespaceL.html#a30852e05bf02e4de3ad59078615f7b75a140909b8b6f7c45dea0ae6233ced9d5e">Num</a></td></tr>
<tr class="memdesc:afb26b29e8d5d8fcc05a2418e3163c816"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the node in the expression tree  <a href="#afb26b29e8d5d8fcc05a2418e3163c816">More...</a><br /></td></tr>
<tr class="separator:afb26b29e8d5d8fcc05a2418e3163c816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dea240e4f2c416a660c013a7b16d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1Expression.html">Expression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#aa8dea240e4f2c416a660c013a7b16d1d">_right</a> = nullptr</td></tr>
<tr class="memdesc:aa8dea240e4f2c416a660c013a7b16d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">right child  <a href="#aa8dea240e4f2c416a660c013a7b16d1d">More...</a><br /></td></tr>
<tr class="separator:aa8dea240e4f2c416a660c013a7b16d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c715ed258189c47c81ad2d527b954d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1Expression.html">Expression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#ac4c715ed258189c47c81ad2d527b954d">_left</a> = nullptr</td></tr>
<tr class="memdesc:ac4c715ed258189c47c81ad2d527b954d"><td class="mdescLeft">&#160;</td><td class="mdescRight">left child  <a href="#ac4c715ed258189c47c81ad2d527b954d">More...</a><br /></td></tr>
<tr class="separator:ac4c715ed258189c47c81ad2d527b954d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f41c079d5792baea325dbab87da037"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a97f41c079d5792baea325dbab87da037">_numerical</a> = 0</td></tr>
<tr class="memdesc:a97f41c079d5792baea325dbab87da037"><td class="mdescLeft">&#160;</td><td class="mdescRight">if _type == Num, the numerical constant associated with the node  <a href="#a97f41c079d5792baea325dbab87da037">More...</a><br /></td></tr>
<tr class="separator:a97f41c079d5792baea325dbab87da037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf08989c57c4683b2583ab4c3026e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classL_1_1CoreVariable.html">CoreVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a9cf08989c57c4683b2583ab4c3026e80">_variable</a> = nullptr</td></tr>
<tr class="memdesc:a9cf08989c57c4683b2583ab4c3026e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">if _type == Var, the variable associated with the node  <a href="#a9cf08989c57c4683b2583ab4c3026e80">More...</a><br /></td></tr>
<tr class="separator:a9cf08989c57c4683b2583ab4c3026e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6acf8d0664dd23c5970e349d3d663e"><td class="memItemLeft" align="right" valign="top">unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a6e6acf8d0664dd23c5970e349d3d663e">_id</a> = <a class="el" href="classL_1_1Expression.html#affc3146c7a317e3bdfb117842eafe8de">_expression_id</a>++</td></tr>
<tr class="memdesc:a6e6acf8d0664dd23c5970e349d3d663e"><td class="mdescLeft">&#160;</td><td class="mdescRight">expression's id  <a href="#a6e6acf8d0664dd23c5970e349d3d663e">More...</a><br /></td></tr>
<tr class="separator:a6e6acf8d0664dd23c5970e349d3d663e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:affc3146c7a317e3bdfb117842eafe8de"><td class="memItemLeft" align="right" valign="top">static unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#affc3146c7a317e3bdfb117842eafe8de">_expression_id</a> = 0</td></tr>
<tr class="memdesc:affc3146c7a317e3bdfb117842eafe8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">general expression counter, used as id  <a href="#affc3146c7a317e3bdfb117842eafe8de">More...</a><br /></td></tr>
<tr class="separator:affc3146c7a317e3bdfb117842eafe8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:adc798230a847c3341037f76bad96b75c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#adc798230a847c3341037f76bad96b75c">transfer</a> (<a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> from_side, <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;from_expr, <a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> to_side, <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;to_expr)</td></tr>
<tr class="memdesc:adc798230a847c3341037f76bad96b75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a child node from a source node to a destination node's child. No copy is performed.  <a href="#adc798230a847c3341037f76bad96b75c">More...</a><br /></td></tr>
<tr class="separator:adc798230a847c3341037f76bad96b75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e56a1ef0797b2d69992f590568bc9f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classL_1_1Expression.html#a3e56a1ef0797b2d69992f590568bc9f4">swap</a> (<a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> from_side, <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;from_expr, <a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a> to_side, <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;to_expr)</td></tr>
<tr class="memdesc:a3e56a1ef0797b2d69992f590568bc9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges a child node of 'from_expr' with a child node of 'to_expr'.  <a href="#a3e56a1ef0797b2d69992f590568bc9f4">More...</a><br /></td></tr>
<tr class="separator:a3e56a1ef0797b2d69992f590568bc9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a mathematical expression as an expression tree. </p>
<dl class="section warning"><dt>Warning</dt><dd>Most of the implemented algorithms expect an expanded form of the mathematical expressions yet no ".expand()" function has been written. This is yet to be done. For now, it is, most of the time, assumed that the given expressions are already expanded by the user. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad571b6d602257ff0af3b50f97eaa2a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad571b6d602257ff0af3b50f97eaa2a02">&#9670;&nbsp;</a></span>Expression() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">L::Expression::Expression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a96ee72782c47a4b5a1d8614600f38cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ee72782c47a4b5a1d8614600f38cb8">&#9670;&nbsp;</a></span>Expression() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">L::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a30852e05bf02e4de3ad59078615f7b75">L::ExpressionType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new expression whose root node is of the given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>root node type</td></tr>
  </table>
  </dd>
</dl>
<p>CONSTRUCTORS </p>

</div>
</div>
<a id="a67cfac300978eeb619bf99c7ad50dad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cfac300978eeb619bf99c7ad50dad7">&#9670;&nbsp;</a></span>Expression() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">L::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classL_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new expression whose root is of type Var and is associated to the given variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>variable associated to the expression's root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12cf2c3800815337e91f49bafcb79674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cf2c3800815337e91f49bafcb79674">&#9670;&nbsp;</a></span>Expression() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">L::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>coef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new expression whose root is of type Num and has value 'coef'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coef</td><td>numerical value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11e9e1a9637b14ffd7c14b620405883f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e9e1a9637b14ffd7c14b620405883f">&#9670;&nbsp;</a></span>Expression() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">L::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. The whole expression tree is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the source expression to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a100166b8c53e7bf1e6aa67f37ccf6274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100166b8c53e7bf1e6aa67f37ccf6274">&#9670;&nbsp;</a></span>~Expression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">L::Expression::~Expression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. Frees left and right children. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a0f0ca9ac1d72a75d61e4a2d64c8764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0f0ca9ac1d72a75d61e4a2d64c8764">&#9670;&nbsp;</a></span>apply_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1Expression.html">L::Expression</a> &amp; L::Expression::apply_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a30852e05bf02e4de3ad59078615f7b75">L::ExpressionType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an operator ('*' or '+') on 'this' with rhs as right term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>operator ('*' or '+') </td></tr>
    <tr><td class="paramname">rhs</td><td>right term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>OPERATORS </p>

</div>
</div>
<a id="a0cfbdbec325596ac33e93d10a26d2e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfbdbec325596ac33e93d10a26d2e3c">&#9670;&nbsp;</a></span>as_numerical() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float &amp; L::Expression::as_numerical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the numerical constant associated to the expression if the expression if of type Num (otherwise, throws an exception) </p>
<dl class="section return"><dt>Returns</dt><dd>expression as numerical constant </dd></dl>

</div>
</div>
<a id="ac4e35984f46ddc7528981da4a73ec148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e35984f46ddc7528981da4a73ec148">&#9670;&nbsp;</a></span>as_numerical() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float L::Expression::as_numerical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the numerical constant associated to the expression if the expression if of type Num (otherwise, throws an exception) </p>
<dl class="section return"><dt>Returns</dt><dd>expression as numerical constant </dd></dl>

</div>
</div>
<a id="a4a2ee1e7c303fd02663f6c0d0193332e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2ee1e7c303fd02663f6c0d0193332e">&#9670;&nbsp;</a></span>as_variable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1Variable.html">L::Variable</a> L::Expression::as_variable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variable associated to the expression if the expression is of type Var (otherwise, throws an exception) </p>
<dl class="section return"><dt>Returns</dt><dd>expression as variable </dd></dl>

</div>
</div>
<a id="aecb3585f71cde564157bf83501efdf9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb3585f71cde564157bf83501efdf9b">&#9670;&nbsp;</a></span>as_variable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1ConstVariable.html">L::ConstVariable</a> L::Expression::as_variable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variable associated to the expression if the expression is of type Var (otherwise, throws an exception) </p>
<dl class="section return"><dt>Returns</dt><dd>expression as variable </dd></dl>

</div>
</div>
<a id="ad2a0bd394ee1290f2b91cfcac60cc944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a0bd394ee1290f2b91cfcac60cc944">&#9670;&nbsp;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void L::Expression::attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">L::ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classL_1_1Expression.html">L::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the expression's 'side' child to be 'expr'. No copy is performed. Thus, '&amp;expr' will be destroyed by the expression's constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">side</td><td>Left/Right </td></tr>
    <tr><td class="paramname">expr</td><td>new 'side' child</td></tr>
  </table>
  </dd>
</dl>
<p>SETTERS </p>

</div>
</div>
<a id="a5a9a615a5aea5ad9827f6f68063dd4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a615a5aea5ad9827f6f68063dd4f1">&#9670;&nbsp;</a></span>attach_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void L::Expression::attach_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">L::ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the expression's 'side' child to be 'expr'. The given expression is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">side</td><td>Left/Right </td></tr>
    <tr><td class="paramname">expr</td><td>new 'side' child to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc55fb8bdbbe2024130809f542182286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc55fb8bdbbe2024130809f542182286">&#9670;&nbsp;</a></span>child() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1Expression.html">L::Expression</a> &amp; L::Expression::child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">L::ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the child node located on the expression's 'side' (Left/Right) if any, throws an exception otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">side</td><td>Leff or Right </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>child node located on the expression's 'side' (Left/Right) if any, throws an exception otherwise </dd></dl>

</div>
</div>
<a id="a60d02c47d04b26ff8f1bbcb914cfa08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d02c47d04b26ff8f1bbcb914cfa08e">&#9670;&nbsp;</a></span>child() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classL_1_1Expression.html">L::Expression</a> &amp; L::Expression::child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">L::ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the child node located on the expression's 'side' (Left/Right) if any, throws an exception otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">side</td><td>Leff or Right </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>child node located on the expression's 'side' (Left/Right) if any, throws an exception otherwise </dd></dl>

</div>
</div>
<a id="abd5f871de69faea528cec83250cdcb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5f871de69faea528cec83250cdcb5a">&#9670;&nbsp;</a></span>depth_first_traversal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;L::ExpressionTraversalOrder order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void L::Expression::depth_first_traversal </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classL_1_1Expression.html">Expression</a> &amp;expr)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic implementation of the Depth first traversal on the expression tree. Early stop of the traversal can be performed by throwing a <a class="el" href="classL_1_1StopIteration.html">StopIteration</a> exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>lambda function to be called on each node during traversal </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">order</td><td>traversal order (postfix, infix, prefix) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a601268b35451070221a668c0404464d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601268b35451070221a668c0404464d9">&#9670;&nbsp;</a></span>depth_first_traversal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;L::ExpressionTraversalOrder order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void L::Expression::depth_first_traversal </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;expr)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic implementation of the Depth first traversal on the expression tree. Early stop of the traversal can be performed by throwing a <a class="el" href="classL_1_1StopIteration.html">StopIteration</a> exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>lambda function to be called on each node during traversal </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">order</td><td>traversal order (postfix, infix, prefix) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a064f326a3b41c6462454489a77f4b25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064f326a3b41c6462454489a77f4b25f">&#9670;&nbsp;</a></span>detach_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void L::Expression::detach_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">L::ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and deletes (frees memory) a child. For memory safety reasons, no "detach" without delete (memory free) has been implemented. See transfer/swap for alternatives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">side</td><td>Left/Right </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b5c6d5640489c62efcba84dbceca4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5c6d5640489c62efcba84dbceca4c4">&#9670;&nbsp;</a></span>export_to_dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void L::Expression::export_to_dot </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_system_command</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the expression tree in a .dot file to be used with graphviz. If 'with_system_command' is set to true, the linux command 'dot -Tpng' is executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the destination filename </td></tr>
    <tr><td class="paramname">with_system_command</td><td>true if the linux command to generate a PNG file should be executed by the program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ccd934cf538ce1e31cf099b3ebbb130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ccd934cf538ce1e31cf099b3ebbb130">&#9670;&nbsp;</a></span>feval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float L::Expression::feval </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cast_variables</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the numerical value of an expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cast_variables</td><td>true if the variables encountered should be casted, fase otherwise (an exception is thrown if a variable is found) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>numerical result </dd></dl>

</div>
</div>
<a id="af96e86a455a561989b129c397dcff02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96e86a455a561989b129c397dcff02b">&#9670;&nbsp;</a></span>has_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool L::Expression::has_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">L::ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the expression has a child on its 'side', false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">side</td><td>Left or Right </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the expression has a child on its 'side', false otherwise </dd></dl>

</div>
</div>
<a id="ab9196bd881e791dccd790893fa7648c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9196bd881e791dccd790893fa7648c0">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long int L::Expression::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns expression's id. </p>
<dl class="section return"><dt>Returns</dt><dd>expression's id</dd></dl>
<p>GETTERS </p>

</div>
</div>
<a id="af2cf5ee5682c0c0f2c2b0b3c055c6045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cf5ee5682c0c0f2c2b0b3c055c6045">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void L::Expression::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">L::ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classL_1_1Expression.html">L::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the expression's 'side' child to be 'expr'. If the expression already has a 'side' child, it will be moved to 'expr''s side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">side</td><td>Left/Right </td></tr>
    <tr><td class="paramname">expr</td><td>child to be inserted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac26c7d426f321c2ecc03b7462d7e0cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26c7d426f321c2ecc03b7462d7e0cf4">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1Expression.html">L::Expression</a> &amp; L::Expression::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Product overload. See <a class="el" href="classL_1_1Expression.html#a6a0f0ca9ac1d72a75d61e4a2d64c8764" title="Applies an operator (&#39;*&#39; or &#39;+&#39;) on &#39;this&#39; with rhs as right term. ">apply_operator()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>right term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a59b7b1109603397df3d0cb1b440bfaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b7b1109603397df3d0cb1b440bfaeb">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1Expression.html">L::Expression</a> &amp; L::Expression::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition overload. See <a class="el" href="classL_1_1Expression.html#a6a0f0ca9ac1d72a75d61e4a2d64c8764" title="Applies an operator (&#39;*&#39; or &#39;+&#39;) on &#39;this&#39; with rhs as right term. ">apply_operator()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>right term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a1d7c56ec0c7611529025ac685363158b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7c56ec0c7611529025ac685363158b">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1Expression.html">L::Expression</a> &amp; L::Expression::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>right term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a28b6afa689d58f2916c6ea5458fb49ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b6afa689d58f2916c6ea5458fb49ed">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1Expression.html">L::Expression</a> &amp; L::Expression::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Division overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>right term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a519ba150940dedfa5dd54e90ce472f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519ba150940dedfa5dd54e90ce472f39">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1Expression.html">L::Expression</a> &amp; L::Expression::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign constructor. The whole expression is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the source expression to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a9a8fb4f5a0efea1cb21f6bfac962d4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8fb4f5a0efea1cb21f6bfac962d4ac">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void L::Expression::shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">L::ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts the root node to the 'side'. The expression therefore ends with a child which is the previous root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">side</td><td>Left/Right </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7640c4e69d9982c46387ecc8650216d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7640c4e69d9982c46387ecc8650216d9">&#9670;&nbsp;</a></span>split_by_variable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="classL_1_1Expression.html">L::Expression</a> &gt; L::Expression::split_by_variable </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::function&lt; bool(const <a class="el" href="classL_1_1Variable.html">Variable</a> &amp;)&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>indicators</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of variable indicators, i.e., a set of lambda function which respond true for some variables and false for others, returns a set of subexpressions composed only of those variables for which the associated indicator returns true for all of its variables. Note that the given indicators MUST define a separable expression in those variables. For instance, "x * y" cannot be separated by the two following indicators: <code>c++ [](const <a class="el" href="classL_1_1Variable.html" title="Indirection to a core variable. ">Variable</a>&amp; var){ return var.user_defined_name() == "x"; } and [](const <a class="el" href="classL_1_1Variable.html" title="Indirection to a core variable. ">Variable</a>&amp; var){ return var.user_defined_name() == "y"; }</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indicators</td><td>map between a string (indicator's name) and a lambda function returning true for some variables, false for others. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>set of subexpressions associated to each indicator by name </dd></dl>

</div>
</div>
<a id="a2c88ee27d7574232d07c441c823410f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c88ee27d7574232d07c441c823410f5">&#9670;&nbsp;</a></span>to_elementary_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string L::Expression::to_elementary_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string expression representing the expression's root node. </p>
<dl class="section return"><dt>Returns</dt><dd>string expression representing the expression's root node </dd></dl>

</div>
</div>
<a id="a7cd9b53defd859a111733f0d180a32b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd9b53defd859a111733f0d180a32b7">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string L::Expression::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the expression as a string. </p>
<dl class="section return"><dt>Returns</dt><dd>expression as a string </dd></dl>

</div>
</div>
<a id="a581b6516fa543f9d01f19c45e273282e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581b6516fa543f9d01f19c45e273282e">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceL.html#a30852e05bf02e4de3ad59078615f7b75">L::ExpressionType</a> L::Expression::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns expression's type. </p>
<dl class="section return"><dt>Returns</dt><dd>expression's type </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3e56a1ef0797b2d69992f590568bc9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e56a1ef0797b2d69992f590568bc9f4">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>from_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>from_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>to_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>to_expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges a child node of 'from_expr' with a child node of 'to_expr'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_side</td><td>Left/Right </td></tr>
    <tr><td class="paramname">from_expr</td><td>expression 1 </td></tr>
    <tr><td class="paramname">to_side</td><td>Left/Right </td></tr>
    <tr><td class="paramname">to_expr</td><td>expression 2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc798230a847c3341037f76bad96b75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc798230a847c3341037f76bad96b75c">&#9670;&nbsp;</a></span>transfer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>from_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>from_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceL.html#a361042d7dd9d3c4e5de494ab3acc4dff">ExpressionSide</a>&#160;</td>
          <td class="paramname"><em>to_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classL_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>to_expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a child node from a source node to a destination node's child. No copy is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_side</td><td>Left/Right </td></tr>
    <tr><td class="paramname">from_expr</td><td>source node whose 'from_side' child will be transfered to to_expr </td></tr>
    <tr><td class="paramname">to_side</td><td>Left/Right </td></tr>
    <tr><td class="paramname">to_expr</td><td>destination node whose 'to_side' child will become 'from_expr''s 'from_side''s child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="affc3146c7a317e3bdfb117842eafe8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc3146c7a317e3bdfb117842eafe8de">&#9670;&nbsp;</a></span>_expression_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long int L::Expression::_expression_id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>general expression counter, used as id </p>

</div>
</div>
<a id="a6e6acf8d0664dd23c5970e349d3d663e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6acf8d0664dd23c5970e349d3d663e">&#9670;&nbsp;</a></span>_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long int L::Expression::_id = <a class="el" href="classL_1_1Expression.html#affc3146c7a317e3bdfb117842eafe8de">_expression_id</a>++</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>expression's id </p>

</div>
</div>
<a id="ac4c715ed258189c47c81ad2d527b954d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c715ed258189c47c81ad2d527b954d">&#9670;&nbsp;</a></span>_left</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1Expression.html">Expression</a>* L::Expression::_left = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>left child </p>

</div>
</div>
<a id="a97f41c079d5792baea325dbab87da037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f41c079d5792baea325dbab87da037">&#9670;&nbsp;</a></span>_numerical</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float L::Expression::_numerical = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if _type == Num, the numerical constant associated with the node </p>

</div>
</div>
<a id="aa8dea240e4f2c416a660c013a7b16d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dea240e4f2c416a660c013a7b16d1d">&#9670;&nbsp;</a></span>_right</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1Expression.html">Expression</a>* L::Expression::_right = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>right child </p>

</div>
</div>
<a id="afb26b29e8d5d8fcc05a2418e3163c816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb26b29e8d5d8fcc05a2418e3163c816">&#9670;&nbsp;</a></span>_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceL.html#a30852e05bf02e4de3ad59078615f7b75">ExpressionType</a> L::Expression::_type = <a class="el" href="namespaceL.html#a30852e05bf02e4de3ad59078615f7b75a140909b8b6f7c45dea0ae6233ced9d5e">Num</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>type of the node in the expression tree </p>

</div>
</div>
<a id="a9cf08989c57c4683b2583ab4c3026e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf08989c57c4683b2583ab4c3026e80">&#9670;&nbsp;</a></span>_variable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classL_1_1CoreVariable.html">CoreVariable</a>* L::Expression::_variable = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if _type == Var, the variable associated with the node </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/hlefebvr/CLionProjects/ed-solver/src/LSolver/modeling/expressions/<a class="el" href="Expression_8h_source.html">Expression.h</a></li>
<li>/home/hlefebvr/CLionProjects/ed-solver/src/LSolver/modeling/expressions/<a class="el" href="Expression_8cpp.html">Expression.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
